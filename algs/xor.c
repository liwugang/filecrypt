/**
 *  xor algorithm
 * 
 * The file contents xor with the xor_key value which is generated by random and
 * the xor_key is encrypted with user password.
 * saved_xor_key = AES(HASH256(FIRST_MAGIC + SECOND_MAGIC + USER_PASSWORD) + xor_key)
 * 
*/

#include "algs.h"

#define RANDOM_LENGTH   8

static uint64_t get_xor_key(file_crypt_info *crypt_info, const char *user_password) {
    int result = FALSE;
    uint8_t hash_and_key[HASH256_SIZE + RANDOM_LENGTH];
    uint64_t length;
    result = aes_decrypt_common(crypt_info->key, crypt_info->key_length, user_password, DEFAULT_IV,
            hash_and_key, &length);
    if (!result || length != HASH256_SIZE + RANDOM_LENGTH) {
        return 0;
    }
    return *(uint64_t *)(hash_and_key + HASH256_SIZE);
}

uint64_t xor_get_crypt_file_length(file_crypt_info *crypt_info) {
    return crypt_info->file_length;
}

/**
 *  AES(HASH256(FIRST_MAGIC + SECOND_MAGIC + password) + xor_key)
*/
int xor_is_right_password(file_crypt_info *crypt_info, const char *user_password) {
    int result = FALSE;
    uint8_t hash_and_key[HASH256_SIZE + RANDOM_LENGTH];
    uint64_t length;
    result = aes_decrypt_common(crypt_info->key, crypt_info->key_length, user_password, DEFAULT_IV,
            hash_and_key, &length);

    if (!result || length != HASH256_SIZE + RANDOM_LENGTH) {
        return FALSE;
    }
    return is_right_password(user_password, hash_and_key);
}

static void xor_data(uint64_t xor_key, void *input_data, void *output_data, uint64_t length) {
    int64_t i;
    uint64_t have_done = 0;
    uint64_t *in, *out;
    uint8_t *in_b, *out_b, *key_b;

    in = (uint64_t *) input_data;
    out = (uint64_t *) output_data;
    for (i = 0; i <= (int64_t)(length - RANDOM_LENGTH); i += RANDOM_LENGTH) {
        *out = *in ^ xor_key;
        in++;
        out++;
        have_done += RANDOM_LENGTH;
    }
    if (have_done != length) {
        in_b = input_data + have_done;
        out_b = output_data + have_done;
        key_b = (uint8_t *) &xor_key;
        for (i = 0; i < length - have_done; i++) {
            *out_b = *in_b ^ key_b[i];
            in_b++;
            out_b++;
        }
    }
}

int xor_encrypt(file_crypt_info *crypt_info, const char *user_password,
                     void *input_data, void *output_data) {

    uint8_t hash_and_key[HASH256_SIZE + RANDOM_LENGTH];
    uint64_t xor_key;

    // xor_key generate randomly
    *(uint32_t *) &xor_key = random();
    *((uint32_t *) &xor_key + 1) = random();
    xor_data(xor_key, input_data, output_data, crypt_info->file_length);

    if (!get_password_hash(user_password, (uint8_t *)&hash_and_key)) {
        return FALSE;
    }
    *(uint64_t *)(hash_and_key + HASH256_SIZE) = xor_key;

    if (!aes_encrypt_common(hash_and_key, HASH256_SIZE + RANDOM_LENGTH, user_password, DEFAULT_IV,
                    crypt_info->key, &crypt_info->key_length)) {
        return FALSE;
    }
    return TRUE;
}

int xor_decrypt(file_crypt_info *crypt_info, const char *user_password,
                     void *input_data, void *output_data) {
    uint64_t xor_key = get_xor_key(crypt_info, user_password);
    if (!xor_key) return FALSE;
    xor_data(xor_key, input_data, output_data, crypt_info->file_length);
    return TRUE;
}

crypt_operations xor_crypt_operations = {
    .get_crypt_file_length = xor_get_crypt_file_length,
    .is_right_password = xor_is_right_password,
    .encrypt = xor_encrypt,
    .decrypt = xor_decrypt,
};